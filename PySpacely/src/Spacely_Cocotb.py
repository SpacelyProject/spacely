import os
import re

from cocotb.runner import get_runner
from cocotbext.axi import AxiLiteBus, AxiLiteMaster

from Master_Config import *
import Spacely_Globals as sg
from Spacely_Utils import *

from Spacely_Caribou import parse_mem_map


COCOTB_ROUTINES_FILENAME = "_temp_cocotb_routines.py"
DIGITAL_TWIN_HDL_TOP_FILENAME = "_temp_digital_twin_hdl_top.sv"

# The goal: Make it so that you can run your routines on the ASIC RTL using Cocotb.
# The steps:
# (1) Produce a copy of your testbench with cocotb asynchronous style syntax.
# (2) Make sure that you are using Virtual Caribou. The Virtual Caribou will have routines that emulate an AXI master.
# (3) Run the routine. 

def run_routine_cocotb(routine_name):
    global SIMULATOR, HDL_TOP_LEVEL, HDL_SOURCES
    
    if SIMULATOR is None:
        sg.log.error("You must define the variable SIMULATOR in your Config.py file to run Cocotb.")
        return -1
        
    if HDL_TOP_LEVEL is None:
        sg.log.error("You must define the variable HDL_TOP_LEVEL in your Config.py file to run Cocotb.")

    if HDL_SOURCES is None:
        sg.log.warning(f"No HDL_SOURCES specified; will use all HDL files in {TARGET}/hdl.")
        HDL_SOURCES = []
        for filename in os.listdir(os.path.join("spacely-asic-config",TARGET,"hdl")):
            if filename.endswith('.v') or filename.endswith('.sv'):
                HDL_SOURCES.append(filename)
        sg.log.debug(f"HDL_SOURCES: {HDL_SOURCES}")
        
        
    sg.log.debug(f"Autogenerating Cocotb Test from {routine_name}...")
    cocotb_test_file = create_cocotb_test(routine_name)
    
    # (1) Set up the runner
    sg.log.debug("Initializing simulator...")
    runner = get_runner(SIMULATOR)

    hdl_top_level_with_path = add_hdl_path(HDL_TOP_LEVEL)+".sv"
    hdl_sources_with_path = [add_hdl_path(x) for x in HDL_SOURCES]
    
    runner.build(
        sources = hdl_sources_with_path,
        hdl_toplevel = HDL_TOP_LEVEL
        )

    # (2) Run the test
    runner.test(hdl_toplevel=HDL_TOP_LEVEL, test_module=cocotb_test_file.replace(".py",""))



AUTOGEN_COCOTB_WARNING="""
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#  ! WARNING! This file was automatically generated by  !
#  ! Spacely_Cocotb. You don't need to modify it, and   !
#  ! if you do, your modifications will be overwritten! !
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""

def add_hdl_path(filename):
    return os.path.join(os.getcwd(),"spacely-asic-config",TARGET,"hdl",filename)

def create_cocotb_test(routine_name):
    """Modifies a ROUTINE from TARGET_ROUTINES.py to be a valid Cocotb test."""
    
    with open(TARGET_ROUTINES_PY,'r') as read_file:
        routines_txt = read_file.read()


    routines_txt = AUTOGEN_COCOTB_WARNING + routines_txt

    routines_txt = routines_txt.replace(f"def {routine_name}(",
                                        f"@cocotb.test()\nasync def {routine_name}(")

    routines_txt = routines_txt.replace("awaitTimer","await Timer")
    
    temp_file = COCOTB_ROUTINES_FILENAME
    
    with open(temp_file,'w') as write_file:
        write_file.write(routines_txt)

    return temp_file





##############################
# Caribou Digital Twin Class #
##############################

#AXI signal definitions which should be added at the top, for Cocotb to connect to.
AXI_SIGNALS_TOP = """
    input wire [10 : 0]                       M{n}_AXI_AWADDR,
    input wire [2 : 0] 			      M{n}_AXI_AWPROT,
    input wire 				      M{n}_AXI_AWVALID,
    output wire 			      M{n}_AXI_AWREADY,
    input wire [31 : 0]                       M{n}_AXI_WDATA,
    input wire [3 : 0]                        M{n}_AXI_WSTRB,
    input wire 				      M{n}_AXI_WVALID,
    output wire 			      M{n}_AXI_WREADY,
    output wire [1 : 0] 		      M{n}_AXI_BRESP,
    output wire 			      M{n}_AXI_BVALID,
    input wire 				      M{n}_AXI_BREADY,
    input wire [10 : 0]                       M{n}_AXI_ARADDR,
    input wire [2 : 0] 			      M{n}_AXI_ARPROT,
    input wire 				      M{n}_AXI_ARVALID,
    output wire 			      M{n}_AXI_ARREADY,
    output wire [31 : 0]                      M{n}_AXI_RDATA,
    output wire [1 : 0] 		      M{n}_AXI_RRESP,
    output wire 			      M{n}_AXI_RVALID,
    input wire 				      M{n}_AXI_RREADY"""

#AXI signal connections which should be added to each module.
AXI_SIGNALS_MOD = """.S_AXI_ACLK(AXI_ACLK),
        .S_AXI_ARADDR(M{n}_AXI_ARADDR[10:0]),
        .S_AXI_ARESETN(AXI_ARESETN),
        .S_AXI_ARPROT(M{n}_AXI_ARPROT),
        .S_AXI_ARREADY(M{n}_AXI_ARREADY),
        .S_AXI_ARVALID(M{n}_AXI_ARVALID),
        .S_AXI_AWADDR(M{n}_AXI_AWADDR[10:0]),
        .S_AXI_AWPROT(M{n}_AXI_AWPROT),
        .S_AXI_AWREADY(M{n}_AXI_AWREADY),
        .S_AXI_AWVALID(M{n}_AXI_AWVALID),
        .S_AXI_BREADY(M{n}_AXI_BREADY),
        .S_AXI_BRESP(M{n}_AXI_BRESP),
        .S_AXI_BVALID(M{n}_AXI_BVALID),
        .S_AXI_RDATA(M{n}_AXI_RDATA),
        .S_AXI_RREADY(M{n}_AXI_RREADY),
        .S_AXI_RRESP(M{n}_AXI_RRESP),
        .S_AXI_RVALID(M{n}_AXI_RVALID),
        .S_AXI_WDATA(M{n}_AXI_WDATA),
        .S_AXI_WREADY(M{n}_AXI_WREADY),
        .S_AXI_WSTRB(M{n}_AXI_WSTRB),
        .S_AXI_WVALID(M{n}_AXI_WVALID),"""


class CaribouTwin(Source_Instrument):


    def __init__(self, hdl_top_file, mem_map_file, dut=None):
        """Creates a CaribouTwin Object. 
           Parameters:
        hdl_top_file -- HDL file which is the top (including Caribou and ASIC RTL)
        mem_map_file -- mem_map.txt file associated with the Caribou FW. 

        """

        self._setup_digital_twin_hdl(hdl_top_file)
        self._parse_mem_map(mem_map_file)

        # The CaribouTwin has an individual AXI interface for each block.

        # axi_block_addr keeps track of which block address applies to each
        # numbered AXI interface.
        # Key = (int) # corresponding to AXI interface.
        # Val = Hex block address. 
        self.axi_block_addr = {}

        # axi is a list of the axi interfaces by number.
        self.axi = []

        # Dictionaries of voltages and currents to implement the get/set interface.
        self.voltages = {}
        self.currents = {}
        
        if dut is not None:
            self.connect_dut(dut)



    def _parse_mem_map(self, mem_map_file):
        """Get mem_map information from file, and use it to map each field to an Axi Interface."""


        axi_interfaces = list(self.axi_block_addr.keys())

        if len(axi_interfaces) == 0:
            sg.log.error("AXI Interfaces must be created in HDL_TOP before running _parse_mem_map()")
        
        with open(mem_map_file,'r') as read_file:
            lines = read_file.readlines()

        # ########################################
        # # Step 1: Parse mem_map to dictionary. #
        # ########################################
        #
        # Structure of the dictionary (from Spacely_Caribou.py)
        #
        #   mem_map["reg_name"] = {"IP Base Addr" : 0x400000000
        #                          "Register Offs": (int)
        #                          "Mask"         : (int)
        #                          "Readable"     : (bool)
        #                          "Writeable"    : (bool)}
        #
            
        result = parse_mem_map(lines)

        if result == -1:
            sg.log.error("CaribouTwin memory map read failed due to previous parse error!")

        self.mem_map = result


        # #############################################################
        # # Step 2: Assign Digital Twin Interfaces for each register. #
        # #############################################################

        for i in axi_interfaces:
            block_addr = int(self.axi_block_addr[i],16)

            for field in self.mem_map.keys():
                
                #For fields which fall into this block:
                this_field_block_addr = self.mem_map[field]["IP Base Addr"]
                print(f"{block_addr} {this_field_block_addr}")
                if this_field_block_addr == block_addr:
                    
                    if "TwinInterface" in self.mem_map[field]:
                        existing_iface = self.mem_map[field]["TwinInterface"]
                        sg.log.error(f"Mem map field {field} falls into block {block_addr} which is mapped to Digital Twin Interface {i}, but it is already assigned to Interface {existing_iface}.")

                    self.mem_map[field]["TwinInterface"] = i

        #Go back at the end and check we actually assigned an interface for every field. 
        for field in self.mem_map.keys():
            if "TwinInterface" not in self.mem_map[field]:
                sg.log.warning(f"Did not assign a Digital Twin Interface for {field}.")
            


    def _setup_digital_twin_hdl(self, hdl_top_file):
        """Edit the user's hdl_top to insert AXI interfaces.""" 
        sg.log.debug("Setting up digital twin HDL.")

        with open(hdl_top_file,'r') as read_file:
            hdl_txt = read_file.read()

        hdl_txt = self._add_axi_interfaces(hdl_txt)

        with open(DIGITAL_TWIN_HDL_TOP_FILENAME,'w') as write_file:
            write_file.write(hdl_txt)




            
    def _add_axi_interfaces(self, hdl_txt):
        """Given a string representing a .sv file, it will instantiate 
        AXI interfaces at all the blocks which are supposed to have them.
        """

        # Initialize counter and dictionary for mappings
        counter = 0
        hex_dict = {}

        # Regular expression pattern to match AXI_INTERFACE comments with hex numbers
        pattern = re.compile(r'/\*AXI_INTERFACE\((0x[0-9A-Fa-f]+)\)\*/')

        # Replace each AXI_INTERFACE comment and store the mappings
        def replacer(match):
            nonlocal counter
            hex_value = match.group(1)
            hex_dict[counter] = hex_value
            replacement = AXI_SIGNALS_MOD.replace("{n}",str(counter))
            counter += 1
            return replacement

        # Add AXI interfaces to each module.
        hdl_txt = pattern.sub(replacer, hdl_txt)

        # Add AXI signals to the interface of the top module.
        new_header_txt = "top (input logic AXI_ACLK,\n input logic AXI_ARESETN,\n"

        for i in range(counter):
            new_header_txt += AXI_SIGNALS_TOP.replace("{n}",str(i))

        hdl_txt = re.sub(r'top\s*\(', new_header_txt, hdl_txt)

        #Save AXI block addresses per interface for later.
        self.axi_block_addr = hex_dict


        if counter == 0:
            sg.log.error("Didn't find any blocks which have AXI interfaces! Did you forget to add comments, or is the HDL_TOP file wrong?")
        
        # Return the text after modification.
        return hdl_txt



    def connect_dut(self, dut):
        self.dut = dut

        axi_interfaces = list(self.axi_block_addr.keys())

        if len(axi_interfaces) == 0:
            sg.log.error("AXI Interfaces must be created in HDL_TOP before running connect_dut()")

        for i in axi_interfaces:
            self.axi.append(AxiLiteMaster(AxiLiteBus.from_prefix(f"M{i}_AXI"),dut.AXI_ACLK, dut.AXI_ARESETN))

        


    async def set_memory(self, mem_name, value):
        await self.axi.write_dword()

    async def get_memory(self, mem_name):
        pass



    def set_voltage(self, channel, nominal_voltage, current_limit):
        self.voltages[channel] = nominal_voltage
      
    def set_current(self, channel, nominal_current, voltage_limit):
        self.currents[channel] = nominal_current

    def get_voltage(self, channel):
        return self.voltages[channel]
      
    def get_current(self, channel):
        return self.currents[channel]
        
    def set_output_on(self, channel):
        pass
        
    def set_output_off(self, channel):
        pass

    def disable_all_pwr_rails(self):
        pass

    def close(self):
        pass
