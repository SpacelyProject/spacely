import os
import re

from cocotb.runner import get_runner
from cocotbext.axi import AxiLiteBus, AxiLiteMaster

from Master_Config import *
import Spacely_Globals as sg
from Spacely_Utils import *

from Spacely_Caribou import parse_mem_map


COCOTB_ROUTINES_FILENAME = "_temp_cocotb_routines.py"
AUTOGEN_DIGITAL_TWIN_FILENAME = "_temp_digital_twin_hdl_top.sv"

DEFAULT_MEM_MAP_FILE = os.path.join("spacely-asic-config",TARGET,"hdl","mem_map.txt")
DEFAULT_SOURCES_FILE = os.path.join("spacely-asic-config",TARGET,"hdl","hdl_sources.txt")
DEFAULT_DIGITAL_TWIN_TOP_FILE = os.path.join("spacely-asic-config",TARGET,"hdl","CaribouDigitalTwinTop.sv")

# The goal: Make it so that you can run your routines on the ASIC RTL using Cocotb.
# The steps:
# (1) Produce a copy of your testbench with cocotb asynchronous style syntax.
# (2) Make sure that you are using Virtual Caribou. The Virtual Caribou will have routines that emulate an AXI master.
# (3) Run the routine. 

def run_routine_cocotb(routine_name):
    global SIMULATOR, HDL_TOP_MODULE

    ## (1) Check that global variables are set.
    
    if SIMULATOR is None:
        sg.log.error("You must define the variable SIMULATOR in your Config.py file to run Cocotb.")
        return -1
        
    if HDL_TOP_MODULE is None:
        sg.log.error("You must define the variable HDL_TOP_MODULE in your Config.py file to run Cocotb.")
        return -1

    ## (2) Obtain HDL source files.

    try:
        with open(DEFAULT_SOURCES_FILE,'r') as r:
            source_lines = [x.strip() for x in r.readlines()]
            #Filter empty and commented lines.
            source_lines = [x for x in source_lines if x and not x.startswith("//")]
            
    except FileNotFoundError:
        sg.log.error(f"Please list your HDL source files in {default_source_file}.")
        return -1

    hdl_sources_with_path = [add_hdl_path(x) for x in source_lines]

    ## (3) If this is a Caribou Digital Twin run, then make sure the source file with the CaribouDigitalTwin in it is
    ##     replaced by the auto-generated top-level.

    if HDL_TOP_MODULE == "CaribouDigitalTwinTop":
       
        if not os.path.exists(DEFAULT_DIGITAL_TWIN_TOP_FILE):
            sg.log.error("You set HDL_TOP_MODULE='CaribouDigitalTwinTop', but didn't find 'CaribouDigitalTwinTop.sv' in your HDL source files.")
            return -1
        else:
            sg.log.debug(f"{DEFAULT_DIGITAL_TWIN_TOP_FILE} will be replaced by the autogenerated {AUTOGEN_DIGITAL_TWIN_FILENAME} in simulation.")

    myFile = add_hdl_path("CaribouDigitalTwinTop.sv")

    if myFile in hdl_sources_with_path:
        hdl_sources_with_path[hdl_sources_with_path.index(myFile)] = AUTOGEN_DIGITAL_TWIN_FILENAME
    else:
        hdl_sources_with_path.append(AUTOGEN_DIGITAL_TWIN_FILENAME)
        
    sg.log.debug(f"Autogenerating Cocotb Test from {routine_name}...")
    cocotb_test_file = create_cocotb_test(routine_name)
    
    # (1) Set up the runner
    sg.log.debug("Initializing simulator...")
    runner = get_runner(SIMULATOR)

   
    
    runner.build(
        sources = hdl_sources_with_path,
        hdl_toplevel = HDL_TOP_MODULE,
        clean=True,
        timescale = ('1n','1p')
        )

    # (2) Run the test
    runner.test(hdl_toplevel=HDL_TOP_MODULE, test_module=cocotb_test_file.replace(".py",""))



AUTOGEN_COCOTB_WARNING="""
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#  ! WARNING! This file was automatically generated by  !
#  ! Spacely_Cocotb. You don't need to modify it, and   !
#  ! if you do, your modifications will be overwritten! !
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
    

def add_hdl_path(filename):
    return os.path.join(os.getcwd(),"spacely-asic-config",TARGET,"hdl",filename)

def create_cocotb_test(routine_name):
    """Modifies a ROUTINE from TARGET_ROUTINES.py to be a valid Cocotb test."""

    ## (1) Read the original routines file.
    
    with open(TARGET_ROUTINES_PY,'r') as read_file:
        routines_txt = read_file.read()

    ## (2) Find the specific routine we are tasked to run.

    start_idx = routines_txt.find(f"\ndef {routine_name}")
    end_idx   = routines_txt.find("\ndef ",start_idx+1)

    print(f"DBG: {start_idx} {end_idx}")
    
    this_routine_txt = routines_txt[start_idx:end_idx]


    ## (3) Make syntax modifications to this routine only.
    
    this_routine_txt = this_routine_txt.replace(f"def {routine_name}(",
                                        f"@cocotb.test()\nasync def {routine_name}(")

    this_routine_txt = this_routine_txt.replace("awaitTimer","await Timer")

    this_routine_txt = this_routine_txt.replace('sg.INSTR["car"].get_memory','await sg.INSTR["car"].get_memory')

    this_routine_txt = this_routine_txt.replace('sg.INSTR["car"].set_memory','await sg.INSTR["car"].set_memory')

    ## (4) Update the routines txt

    routines_txt = AUTOGEN_COCOTB_WARNING + routines_txt.replace(routines_txt[start_idx:end_idx],this_routine_txt)

    #routines_txt = routines_txt.replace("\nfrom","##")
    #routines_txt = routines_txt.replace("\nimport","##")

    ## (5) Write to file
    
    temp_file = COCOTB_ROUTINES_FILENAME
    
    with open(temp_file,'w') as write_file:
        write_file.write(routines_txt)

    return temp_file





##############################
# Caribou Digital Twin Class #
##############################

#AXI signal definitions which should be added at the top, for Cocotb to connect to.
AXI_SIGNALS_TOP = """
    input wire [10 : 0]                       M{n}_AXI_AWADDR,
    input wire [2 : 0] 			      M{n}_AXI_AWPROT,
    input wire 				      M{n}_AXI_AWVALID,
    output wire 			      M{n}_AXI_AWREADY,
    input wire [31 : 0]                       M{n}_AXI_WDATA,
    input wire [3 : 0]                        M{n}_AXI_WSTRB,
    input wire 				      M{n}_AXI_WVALID,
    output wire 			      M{n}_AXI_WREADY,
    output wire [1 : 0] 		      M{n}_AXI_BRESP,
    output wire 			      M{n}_AXI_BVALID,
    input wire 				      M{n}_AXI_BREADY,
    input wire [10 : 0]                       M{n}_AXI_ARADDR,
    input wire [2 : 0] 			      M{n}_AXI_ARPROT,
    input wire 				      M{n}_AXI_ARVALID,
    output wire 			      M{n}_AXI_ARREADY,
    output wire [31 : 0]                      M{n}_AXI_RDATA,
    output wire [1 : 0] 		      M{n}_AXI_RRESP,
    output wire 			      M{n}_AXI_RVALID,
    input wire 				      M{n}_AXI_RREADY"""

#AXI signal connections which should be added to each module.
AXI_SIGNALS_MOD = """.S_AXI_ACLK(AXI_ACLK),
        .S_AXI_ARADDR(M{n}_AXI_ARADDR[10:0]),
        .S_AXI_ARESETN(AXI_ARESETN),
        .S_AXI_ARPROT(M{n}_AXI_ARPROT),
        .S_AXI_ARREADY(M{n}_AXI_ARREADY),
        .S_AXI_ARVALID(M{n}_AXI_ARVALID),
        .S_AXI_AWADDR(M{n}_AXI_AWADDR[10:0]),
        .S_AXI_AWPROT(M{n}_AXI_AWPROT),
        .S_AXI_AWREADY(M{n}_AXI_AWREADY),
        .S_AXI_AWVALID(M{n}_AXI_AWVALID),
        .S_AXI_BREADY(M{n}_AXI_BREADY),
        .S_AXI_BRESP(M{n}_AXI_BRESP),
        .S_AXI_BVALID(M{n}_AXI_BVALID),
        .S_AXI_RDATA(M{n}_AXI_RDATA),
        .S_AXI_RREADY(M{n}_AXI_RREADY),
        .S_AXI_RRESP(M{n}_AXI_RRESP),
        .S_AXI_RVALID(M{n}_AXI_RVALID),
        .S_AXI_WDATA(M{n}_AXI_WDATA),
        .S_AXI_WREADY(M{n}_AXI_WREADY),
        .S_AXI_WSTRB(M{n}_AXI_WSTRB),
        .S_AXI_WVALID(M{n}_AXI_WVALID)"""




class CaribouTwin(Source_Instrument):


    def __init__(self,  mem_map_file=DEFAULT_MEM_MAP_FILE, dut=None):
        """Creates a CaribouTwin Object. 
           Parameters:
        hdl_top_file -- HDL file which is the top (including Caribou and ASIC RTL)
        mem_map_file -- mem_map.txt file associated with the Caribou FW. 

        """

        self._setup_digital_twin_hdl()
        self._parse_mem_map(mem_map_file)

        # The CaribouTwin has an individual AXI interface for each block.

        # axi_block_addr keeps track of which block address applies to each
        # numbered AXI interface.
        # Key = (int) # corresponding to AXI interface.
        # Val = Hex block address. 
        self.axi_block_addr = {}

        # axi is a list of the axi interfaces by number.
        self.axi = []

        # Dictionaries of voltages and currents to implement the get/set interface.
        self.voltages = {}
        self.currents = {}
        
        if dut is not None:
            self.connect_dut(dut)



    def _parse_mem_map(self, mem_map_file):
        """Get mem_map information from file, and use it to map each field to an Axi Interface."""


        axi_interfaces = list(self.axi_block_addr.keys())

        if len(axi_interfaces) == 0:
            sg.log.error("AXI Interfaces must be created in HDL_TOP before running _parse_mem_map()")
        
        with open(mem_map_file,'r') as read_file:
            lines = read_file.readlines()

        # ########################################
        # # Step 1: Parse mem_map to dictionary. #
        # ########################################
        #
        # Structure of the dictionary (from Spacely_Caribou.py)
        #
        #   mem_map["reg_name"] = {"IP Base Addr" : 0x400000000
        #                          "Register Offs": (int)
        #                          "Mask"         : (int)
        #                          "Readable"     : (bool)
        #                          "Writeable"    : (bool)}
        #
            
        result = parse_mem_map(lines)

        if result == -1:
            sg.log.error("CaribouTwin memory map read failed due to previous parse error!")

        self.mem_map = result


        # #############################################################
        # # Step 2: Assign Digital Twin Interfaces for each register. #
        # #############################################################

        for i in axi_interfaces:
            block_addr = int(self.axi_block_addr[i],16)

            for field in self.mem_map.keys():
                
                #For fields which fall into this block:
                this_field_block_addr = self.mem_map[field]["IP Base Addr"]
                if this_field_block_addr == block_addr:
                    
                    if "TwinInterface" in self.mem_map[field]:
                        existing_iface = self.mem_map[field]["TwinInterface"]
                        sg.log.error(f"Mem map field {field} falls into block {block_addr} which is mapped to Digital Twin Interface {i}, but it is already assigned to Interface {existing_iface}.")

                    self.mem_map[field]["TwinInterface"] = i

        #Go back at the end and check we actually assigned an interface for every field. 
        for field in self.mem_map.keys():
            if "TwinInterface" not in self.mem_map[field]:
                sg.log.warning(f"Did not assign a Digital Twin Interface for {field}.")
            


    def _setup_digital_twin_hdl(self):
        """Edit the user's hdl_top to insert AXI interfaces.""" 
        sg.log.debug("Setting up digital twin HDL.")

        with open(DEFAULT_DIGITAL_TWIN_TOP_FILE,'r') as read_file:
            hdl_txt = read_file.read()

        hdl_txt = self._add_axi_interfaces(hdl_txt)

        with open(AUTOGEN_DIGITAL_TWIN_FILENAME,'w') as write_file:
            write_file.write(hdl_txt)




            
    def _add_axi_interfaces(self, hdl_txt):
        """Given a string representing a .sv file, it will instantiate 
        AXI interfaces at all the blocks which are supposed to have them.
        """

        # Initialize counter and dictionary for mappings
        counter = 0
        hex_dict = {}

        # Regular expression pattern to match AXI_INTERFACE comments with hex numbers,
        # followed by optional whitespace and an optional next character (captured in group 2)
        pattern = re.compile(r'/\*AXI_INTERFACE\((0x[0-9A-Fa-f]+)\)\*/(\s*)(\S?)')

        # Replace each AXI_INTERFACE comment and store the mappings
        def replacer(match):
            nonlocal counter
            hex_value = match.group(1)
            whitespace = match.group(2)
            next_char = match.group(3)
            hex_dict[counter] = hex_value
            replacement = AXI_SIGNALS_MOD.replace("{n}",str(counter))
            counter += 1

            # Determine if a trailing comma is needed
            
            if next_char != ')':
                replacement+=","

            # Add back in the whitespace / next_char.
            return replacement + whitespace + next_char

        # Add AXI interfaces to each module.
        hdl_txt = pattern.sub(replacer, hdl_txt)

        # Add AXI signals to the interface of the top module.
        new_header_txt = "CaribouDigitalTwinTop (input logic AXI_ACLK,\n input logic AXI_ARESETN"

        for i in range(counter):
            new_header_txt += ",\n"+AXI_SIGNALS_TOP.replace("{n}",str(i))

        hdl_txt = re.sub(r'CaribouDigitalTwinTop\s*\(', new_header_txt, hdl_txt)

        #Save AXI block addresses per interface for later.
        self.axi_block_addr = hex_dict


        if counter == 0:
            sg.log.error("Didn't find any blocks which have AXI interfaces! Did you forget to add comments, or is the HDL_TOP file wrong?")
        
        # Return the text after modification.
        return hdl_txt



    def connect_dut(self, dut):
        self.dut = dut

        axi_interfaces = list(self.axi_block_addr.keys())

        if len(axi_interfaces) == 0:
            sg.log.error("AXI Interfaces must be created in HDL_TOP before running connect_dut()")

        for i in axi_interfaces:
            self.axi.append(AxiLiteMaster(AxiLiteBus.from_prefix(f"M{i}_AXI"),dut.AXI_ACLK, dut.AXI_ARESETN))

        


    async def set_memory(self, mem_name, value):
        await self.axi.write_dword()

    async def get_memory(self, mem_name):
        pass



    def set_voltage(self, channel, nominal_voltage, current_limit):
        self.voltages[channel] = nominal_voltage
      
    def set_current(self, channel, nominal_current, voltage_limit):
        self.currents[channel] = nominal_current

    def get_voltage(self, channel):
        return self.voltages[channel]
      
    def get_current(self, channel):
        return self.currents[channel]
        
    def set_output_on(self, channel):
        pass
        
    def set_output_off(self, channel):
        pass

    def disable_all_pwr_rails(self):
        pass

    def close(self):
        pass
